# 一、java面试题
## 1. HashMap实现原理（难度星数：★★★★）

HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。
/**
* The table, resized as necessary. Length MUST Always be a power of two.
 */
transient Entry[] table;
 
static class Node<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    final int hash;
    ……
}

当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标）， 如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。
简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，再根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，
也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。

HashMap的性能参数：
HashMap 包含如下几个构造器：

1．HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。
2．HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。
3．HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。
4．HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和负载因子loadFactor。

负载因子loadFactor衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。

HashMap操作的时间复杂度：
理想情况下HashMap的时间复杂度为O（1）

## 2.ConcurrentHashMap实现原理（难度星数：★★★★）
待补充......

## 3.ArrayList实现原理、扩容机制（难度星数：★★★）
待补充......

## 4.LinkedList实现原理、扩容机制（难度星数：★★★）
待补充......

## 5.ArrayList和LinkedList的区别?（难度星数：★★）
最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

待补充......
## 6.synchronized实现原理（难度星数：★★★★）

**1. 作用**  
原子性：确保线程互斥的访问同步代码；
可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；
有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；

**2. 三种用法** 
当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；
当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；
当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；

**3. 实现原理** 
monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：

如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；
如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；
monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

**4. 锁升级过程** 
待补充......

## 7.volatile理解难度星数：（难度星数：★★★）
1）保证内存可见性

通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即线程每次获取volatile变量的值都是最新的。

当一个变量被 volatile 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。

2）禁止指令重排序
禁止指令重排序的原因：
JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，程序的执行结果不能改变

说明：volatile并不能保证原子性

## 8.synchronized和volatile的区别？（难度星数：★★★）
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
   volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
   synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
1.volatile仅能使用在变量级别；
   synchronized则可以使用在变量、方法、和类级别的
2.volatile仅能实现变量的修改可见性，并不能保证原子性；
   synchronized则可以保证变量的修改可见性和原子性
3.volatile不会造成线程的阻塞；
   synchronized可能会造成线程的阻塞。
4.volatile标记的变量不会被编译器优化；
   synchronized标记的变量可以被编译器优化

## 9.java对象头包含哪些内容（难度星数：★★★）
待补充......

## 10.ReentrantLock实现原理（难度星数：★★★★）
待补充......

## 11.ReentrantReadWriteLock原理（难度星数：★★★★）

## 12.synchronized和ReentrantLock的区别（难度星数：★★★）
synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： 
（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 
（2）ReentrantLock可以获取各种锁的信息 
（3）ReentrantLock可以灵活地实现多路通知 
另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。

## 13.ThreadLocal实现原理和内存泄露（难度星数：★★★）
待补充......

## 14.ThreadLocalRandom原理（难度星数：★★★）
待补充......

## 15.进程和线程的区别（难度星数：★★★）

## 16.乐观锁和悲观锁区别（难度星数：★★）
乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

## 17.什么是可重入锁？（难度星数：★★★）
待补充......

## 18.什么是自旋锁？（难度星数：★★★）
待补充......

## 19.公平锁和非公平锁的区别（难度星数：★★★）
待补充......

## 20.独占锁和共享锁的区别（难度星数：★★★）
待补充......

## 21.如何实现接口的幂等性（难度星数：★★★）

## 22.AQS底层原理（难度星数：★★★★★）

## 23.CountDownLatch原理和使用（难度星数：★★★★）

## 24.CyclicBarrier原理和使用（难度星数：★★★★）

## 25.Semaphore原理和使用（难度星数：★★★★）

## 26.ThreadPoolExecutor线程池核心参数和原理（难度星数：★★★）

## 27.ConcurrentLinkedQueue原理（难度星数：★★★★）

## 28.LinkedBlockingQueue原理（难度星数：★★★★）

## 29.ArrayBlockingQueue原理（难度星数：★★★★）

## 30.PriorityBlockingQueue原理（难度星数：★★★★）

## 31.DelayQueue原理（难度星数：★★★★）

## 32.JAVA中父类与子类静态代码块、非静态代码块、构造函数的加载顺序（难度星数：★★）
父类静态代码块 -> 子类静态代码块 -> 父类构造代码块 -> 父类构造函数 -> 子类构造代码块 -> 子类构造函数
静态代码块,在这个类加载的时候会执行,并且只执行一次,在创建对象之前会执行非静态代码块,并且在每次创建对象之前都会执行一次

总之：静态代码块总是最先执行的; 
子类和父类的静态代码块都执行完之后，在执行父类的非静态代码块和父类的构造方法,最后执行子类的非静态代码块和构造方法.

## 33.Comparator和Comparable的区别?（难度星数：★）
Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。
Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

## 34.Java的数据结构有哪些？（难度星数：★）
线性表（ArrayList）
链表（LinkedList）
栈（Stack）
队列（Queue）
图（Map）
树（Tree）

## 35.java 创建对象的几种方式（难度星数：★）
1.采用new
2.通过反射
3.采用clone
4.通过序列化机制

## 36.java当中的四种引用（难度星数：★★）
强引用，软引用，弱引用，虚引用。不同的引用类型主要体现在GC上:

强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。

软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。

弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。

虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

## 37.反射中，Class.forName和classloader的区别（难度星数：★★）
java中class.forName()和classLoader都可用来对类进行加载。
class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象

## 38.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？（难度星数：★）
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：
final StringBuffer a = new StringBuffer("immutable");
执行如下语句将报告编译期错误：
A = new StringBuffer("");
但是，执行如下语句则可以通过编译：
a.append(" broken!");  

## 39.Java线程具有五种状态（难度星数：★）

**1. 新建状态（New）**  
当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread()。

**2. 就绪状态（Runnable）**  
当调用线程对象的 start()方法（t.start();），线程 即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时 等待 CPU 调度执行，并不是说执行了 t.start()此线程立即就会执行； 

**3. 运行状态（Running）**  
当 CPU 开始调度处于就绪状态的线程时，此时线程 才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入 口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 

**4. 阻塞状态（Blocked）**  
处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再 次被 CPU 调用以进入到运行状态。 根据阻塞产生的原因不同，
阻塞状态又可以分为三种： 
 1、等待阻塞：运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态； 
 2、同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)， 它会进入同步阻塞状态； 
 3、其他阻塞：通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入 到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理 完毕时，线程重新转入就绪状态。 

**5. 死亡状态（Dead）**  
线程执行完了或者因异常退出了 run()方法，该线程结束 生命周期。


# 二、JVM面试题

## 1.虚拟机的类的加载机制（难度星数：★★★）

## 2.JVM运行时数据区域（难度星数：★★★）

## 3.JVM内存模型（难度星数：★★★）

## 4.什么是双亲委派机制？（难度星数：★★★）

##  5.类加载器有哪些？（难度星数：★★★）

## 6.java类的加载时机（难度星数：★★★）

# 三、Spring面试题

## 1.BeanFactory和ApplicationContext的区别（难度星数：★★★）

## 2.Spring的作用范围有哪些（难度星数：★★）

##3.Spring的生命周期（难度星数：★★★★）

## 4.Spring的加载方式有哪些？（难度星数：★★）

## 5.Spring的事务传播机制（难度星数：★★★）

## 6.Spring的注入方式有哪些？（难度星数：★★）

## 7.Spring的循环依赖问题，什么时候报异常（难度星数：★★★★）

## 8.谈谈springboot "约定大于配置"（难度星数：★★）


# 四、数据库面试题

## 1.查询重复的名字（难度星数：★）

## 2.乐观锁和悲观锁的实现（难度星数：★★★）

## 3.spring事务的隔离级别（难度星数：★★★）

## 4.索引的底层数据结构有哪些？有什么区别（难度星数：★★★★）

## 5.MySQL性能如何优化（难度星数：★★★）

## 6.B +树比B树做了哪些优化（难度星数：★★★★★）

# 五、Redis面试题

## 1.Redis的数据类型有哪些（难度星数：★★）

## 2.Redis的常见命令有哪些（难度星数：★★★）

## 3.如何设置Redis的key的过期时间（难度星数：★★）

## 4.Redis持久化的方式有哪些？有什么区别（难度星数：★★★）

## 5.redis的key过期策略（难度星数：★★★）

## 6.Redis集群的方法有哪些（难度星数：★★★）

## 7.Redis的缓存穿透（难度星数：★★★）

## 8.Redis的雪崩效应，如何解决（难度星数：★★★）







