- [Java内存区域](#Java内存区域)
  - [程序计数器](#程序计数器)
  - [Java虚拟机栈](#Java虚拟机栈)
  - [本地方法栈](#本地方法栈)
  - [Java堆](#Java堆)
  - [方法区](#方法区)
  - [运行时常量池](#运行时常量池)
  - [直接内存](#直接内存)
- [虚拟机对象](#虚拟机对象)
  - [对象的创建](#对象的创建)
  - [对象的内存分布](#对象的内存分布)
    - [对象头](#对象头)
    - [实例数据](#实例数据)
    - [对齐填充](#对齐填充)
- [类文件结构](#类文件结构)
  - [Class类文件的结构](#Class类文件的结构)
  - [字节码指令](#字节码指令)
- [虚拟机类加载机制](#虚拟机类加载机制)
  - [类加载的时机](#类加载的时机)
  - [类加载的过程](#类加载的过程)
  - [类加载器](#类加载器有哪些)
    - [类与类加载器](#类与类加载器)  
    - [双亲委派机制](#双亲委派机制)  
    - [破坏双亲委派机制](#破坏双亲委派机制)
- [Java内存模型与线程](#Java内存模型与线程)
  - [Java内存模型](#Java内存模型)
    - [主内存和工作内存](#主内存和工作内存)
    - [volatile](#volatile)
  - [Java与线程](#Java与线程)
     - [线程的实现](#线程的实现)
     - [Java线程调度](#Java线程调度)
     - [Java线程状态和转换](#Java线程状态和转换)
- [线程安全和锁优化](#线程安全和锁优化)
  - [Java内存模型](#Java内存模型)
     - [Java线程安全](#Java线程安全)        
     - [线程安全的实现方法](#线程安全的实现方法)
  - [锁优化](#锁优化)
     - [自旋锁和自适应自旋](#自旋锁和自适应自旋)        
     - [锁消除](#锁消除)
     - [锁粗化](#锁粗化)
     - [轻量级锁](#轻量级锁)
     - [偏向锁](#偏向锁)
## Java内存区域

### java对象头包含哪些内容

对象大致可以分为三个部分，分别是对象头、实例变量和填充字节

**对象头（Object header）**

- Mark Word：对象的Mark Word部分占4个字节，其内容是一系列的标记位，比如轻量级的标记位（00），偏向锁标记位（01）等等。
  用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID等。Mark Word
  被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。 

- Class对象指针：Class对象指针的大小也是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。


**对象实际数据**

- 这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，refrence是4个字节。

**对齐填充**

- 最后一部分是对齐填充的字节，按8个字节填充

## 虚拟机类加载机制

## 什么是双亲委派机制？

- 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委派给父加载器去完成，
依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。

**双亲委派机制:**

1、 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。

2、 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。

3、 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；

4、 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。

## 类加载的时机

遇到new, getstatic, putstatic, invokestatic这四条字节码指令的时候，如果类型还没有被初始化，则需要初始化。

new :实例化对象（对象实例调用表达式所创建的对象）

getstatic/putstatic: 读取/设置类的静态字段（被final修饰的静态常量除外）

invokestatic: 调用类的静态方法

## 类加载过程


## 类加载器有哪些？

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：

- BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。
- ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
- AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

## 如何查看 JVM 当前使用的是什么垃圾收集器？

-XX:+PrintCommandLineFlags 参数可以打印出所选垃圾收集器和堆空间大小等设置

如果开启了 GC 日志详细信息，里面也会包含各代使用的垃圾收集器的简称